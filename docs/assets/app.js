// Static files under /docs/data/
const PATHS = {
  catalog: "data/catalog.json",
  boundaries: {
    county: "data/boundaries/counties.topo.json",
    state:  "data/boundaries/states.topo.json",
  },
  lookups: {
    zip:    "data/lookups/zip_centroids_de.json",     // YOU provide (one-time)
    county: "data/lookups/county_centroids.json",     // generated by workflow
    state:  "data/lookups/state_centroids.json",      // generated by workflow
  }
};

const map = L.map("map", { preferCanvas: true }).setView([51.15, 10.45], 6);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 18,
  attribution: "&copy; OpenStreetMap contributors"
}).addTo(map);

let currentLayer = null;
let zipMarker = null;

const cache = {
  catalog: null,
  boundaries: { county: null, state: null },
  lookups: { zip: null, county: null, state: null },
  latestSignalData: new Map(), // key=signal data file path
};

function setStatus(msg) {
  document.getElementById("status").textContent = msg;
}

function getMode() {
  return [...document.querySelectorAll('input[name="mode"]')].find(x => x.checked).value;
}

function normalizeId(v, pad) {
  const s = String(v ?? "").trim();
  if (/^\d+$/.test(s)) return s.padStart(pad, "0");
  return s;
}

function pickColor(v, maxV) {
  if (v == null || !isFinite(v)) return "#cccccc";
  const x = maxV === 0 ? 0 : (v / maxV);
  if (x > 0.85) return "#800026";
  if (x > 0.70) return "#BD0026";
  if (x > 0.55) return "#E31A1C";
  if (x > 0.40) return "#FC4E2A";
  if (x > 0.25) return "#FD8D3C";
  if (x > 0.10) return "#FEB24C";
  return "#FFEDA0";
}

function haversineKm(lat1, lon1, lat2, lon2) {
  const R = 6371.0088;
  const toRad = deg => deg * Math.PI / 180;
  const p1 = toRad(lat1), p2 = toRad(lat2);
  const dLat = p2 - p1;
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(p1) * Math.cos(p2) * Math.sin(dLon / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(a));
}

async function loadJson(path, { noCache = false } = {}) {
  const opts = noCache ? { cache: "no-cache" } : {};
  const r = await fetch(path, opts);
  if (!r.ok) throw new Error(`Failed to load ${path} (${r.status})`);
  return await r.json();
}

async function loadCatalog() {
  if (cache.catalog) return cache.catalog;
  cache.catalog = await loadJson(PATHS.catalog, { noCache: true });
  return cache.catalog;
}

async function loadBoundary(level) {
  if (cache.boundaries[level]) return cache.boundaries[level];
  const topo = await loadJson(PATHS.boundaries[level]);
  const objName = Object.keys(topo.objects)[0];
  const geo = topojson.feature(topo, topo.objects[objName]);
  cache.boundaries[level] = geo;
  return geo;
}

async function loadLookup(kind) {
  if (cache.lookups[kind]) return cache.lookups[kind];
  try {
    cache.lookups[kind] = await loadJson(PATHS.lookups[kind], { noCache: true });
    return cache.lookups[kind];
  } catch (e) {
    cache.lookups[kind] = null;
    return null;
  }
}

async function loadSignalData(signal) {
  // signal.dataFile is like "data/signals/....json"
  // Always reload because workflow updates it
  return await loadJson(signal.dataFile, { noCache: true });
}

function featureId(feature, level) {
  const p = feature.properties || {};
  if (level === "county") {
    // AGS 5-digit
    return normalizeId(p.ags || p.AGS || p.id || p.ID || feature.id, 5);
  }
  // State: we expect an ID that matches region_id (2-digit)
  return normalizeId(p.id || p.ID || p.ags || p.AGS || feature.id, 2);
}

function featureName(feature) {
  const p = feature.properties || {};
  return p.name || p.NAME || p.gen || p.GEN || "Region";
}

function setZipControlsVisible() {
  const zipControls = document.getElementById("zipControls");
  zipControls.style.display = (getMode() === "zip") ? "flex" : "none";
}

async function render() {
  const catalog = await loadCatalog();

  const signalId = document.getElementById("signal").value;
  const signal = catalog.signals.find(s => s.id === signalId);
  const metric = document.getElementById("metric").value;
  const mode = getMode();

  setStatus("Loading…");

  const [geo, data] = await Promise.all([
    loadBoundary(signal.level),
    loadSignalData(signal),
  ]);

  const pad = (signal.level === "county") ? 5 : 2;

  const byId = new Map();
  for (const row of (data.values || [])) {
    const rid = normalizeId(row.region_id, pad);
    byId.set(rid, row[metric]);
  }

  const vals = [...byId.values()].filter(v => typeof v === "number" && isFinite(v));
  const maxV = vals.length ? Math.max(...vals) : 0;

  let allowed = null;

  if (mode === "zip") {
    const postcode = (document.getElementById("postcode").value || "").trim();
    const radius = Number((document.getElementById("radius").value || "").trim());

    if (!postcode || !radius || !isFinite(radius) || radius <= 0) {
      setStatus(`${signal.label} — ${data.date || data.week || ""} — Enter ZIP and radius.`);
      return;
    }

    const [zipCentroids, regionCentroids] = await Promise.all([
      loadLookup("zip"),
      loadLookup(signal.level),
    ]);

    if (!zipCentroids || !regionCentroids) {
      setStatus("ZIP mode needs: data/lookups/zip_centroids_de.json and region centroid lookup files.");
      return;
    }

    const z = zipCentroids[postcode];
    if (!z) {
      setStatus(`ZIP "${postcode}" not found in zip_centroids_de.json`);
      return;
    }

    const center = { lat: Number(z.lat), lon: Number(z.lon) };
    allowed = new Set();

    for (const [ridRaw, c] of Object.entries(regionCentroids)) {
      const rid = normalizeId(ridRaw, pad);
      const d = haversineKm(center.lat, center.lon, Number(c.lat), Number(c.lon));
      if (d <= radius) allowed.add(rid);
    }

    if (zipMarker) zipMarker.remove();
    zipMarker = L.marker([center.lat, center.lon]).addTo(map).bindPopup(`ZIP ${postcode}`).openPopup();
    map.setView([center.lat, center.lon], radius <= 10 ? 10 : radius <= 25 ? 9 : 8);

    setStatus(`${signal.label} — ${data.date || data.week || ""} — ZIP ${postcode} + ${radius} km — regions: ${allowed.size}`);
  } else {
    if (zipMarker) { zipMarker.remove(); zipMarker = null; }
    setStatus(`${signal.label} — ${data.date || data.week || ""} — All Germany`);
  }

  function style(feature) {
    const rid = featureId(feature, signal.level);
    const v = byId.get(rid);
    const inside = (allowed === null) ? true : allowed.has(rid);

    return {
      weight: inside ? 0.7 : 0.4,
      opacity: 1,
      color: "#ffffff",
      fillOpacity: inside ? 0.78 : 0.15,
      fillColor: inside ? pickColor(v, maxV) : "#dddddd"
    };
  }

  function onEachFeature(feature, lyr) {
    const rid = featureId(feature, signal.level);
    const name = featureName(feature);
    const v = byId.get(rid);

    lyr.on("click", () => {
      const outside = (allowed && !allowed.has(rid)) ? "<br/><i>Outside selected radius</i>" : "";
      lyr.bindPopup(
        `<b>${name}</b><br/>ID: ${rid}<br/>${signal.id} / ${metric}: <b>${v ?? "n/a"}</b>${outside}`
      ).openPopup();
    });
  }

  if (currentLayer) currentLayer.remove();
  currentLayer = L.geoJSON(geo, { style, onEachFeature }).addTo(map);
}

async function initUI() {
  const catalog = await loadCatalog();
  const signalSel = document.getElementById("signal");
  const metricSel = document.getElementById("metric");

  // Signals
  signalSel.innerHTML = "";
  for (const s of catalog.signals) {
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = s.label;
    signalSel.appendChild(opt);
  }

  // Metrics
  function populateMetrics() {
    const s = catalog.signals.find(x => x.id === signalSel.value);
    metricSel.innerHTML = "";
    for (const m of s.metrics) {
      const opt = document.createElement("option");
      opt.value = m.id;
      opt.textContent = m.label;
      metricSel.appendChild(opt);
    }
    metricSel.value = s.defaultMetric;
  }

  signalSel.addEventListener("change", () => { populateMetrics(); render(); });
  metricSel.addEventListener("change", render);

  document.querySelectorAll('input[name="mode"]').forEach(r => {
    r.addEventListener("change", () => {
      setZipControlsVisible();
      render();
    });
  });

  document.getElementById("reload").addEventListener("click", render);

  populateMetrics();
  setZipControlsVisible();
  await render();
}

initUI().catch(e => {
  console.error(e);
  setStatus(`Error: ${e.message}`);
});